filter(time != as.Date("2011-01-01")) %>% #Strukturbrüche auslassen
filter(time != as.Date("2016-01-01")) %>%
drop_na()
})
r_factors <- lapply(r_raw, function(x){
pc <- as_tibble(prcomp(x[-c(1,2)])$x)
bind_cols(x[c(1,2)], pc[,1:20]) %>%
drop_na()
})
r <- r_raw
build_model <- function(series){
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = cv$lambda.min)
model
# model <- lm(dat ~ ., data = series[-1])
# model
#summary(model)$coefficients[,4]
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)]))
models <- lapply(r, function(x) build_model(x))
pred_values <- mapply(predict, lag(models, 1)[-c(1)], covariats[-c(1)])
last_values <- sapply(pred_values, last)
forec <- tibble(time = seq.Date(max(first(r)$time)+months(3), max(last(r)$time), by ="quarter"),
value = last_values) %>%
mutate(time = floor_date(time, "quarter")) %>%
rename(index = value) %>%
# fill(consump, .direction = "up") %>%
# mutate(time = floor_date(time, "quarter")) %>%
# group_by(time) %>%
# mutate(index = mean(index)) %>%
drop_na()
rmse <- sqrt(sum((forec$index - forec$consump)^2)/length(forec$index))
return(list(forecast = forec, rmse = rmse))
}
forecast_q(r, dat)$forcast %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_q(r, dat)$forcast
forecast_q(r, dat)$forecast %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_q <- function(r, dat){
r_raw <- r[1:length(r) %% 3 == 0]
r_raw <- lapply(r_raw, function(x){
mutate(x, time = floor_date(time, "quarter")) %>%
group_by(time) %>%
transmute_at(.vars = vars(-time), .funs =  mean) %>%
ungroup() %>%
unique() %>%
mutate(time = time, across(.cols = -1, function(y) c(0, diff(y,1))), .keep = "used") %>%
left_join(dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #Strukturbrüche auslassen
filter(time != as.Date("2016-01-01")) %>%
drop_na()
})
r_factors <- lapply(r_raw, function(x){
pc <- as_tibble(prcomp(x[-c(1,2)])$x)
bind_cols(x[c(1,2)], pc[,1:20]) %>%
drop_na()
})
r <- r_raw
build_model <- function(series){
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = cv$lambda.min)
model
# model <- lm(dat ~ ., data = series[-1])
# model
#summary(model)$coefficients[,4]
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)]))
models <- lapply(r, function(x) build_model(x))
pred_values <- mapply(predict, lag(models, 1)[-c(1)], covariats[-c(1)])
last_values <- sapply(pred_values, last)
forec <- tibble(time = seq.Date(max(first(r)$time)+months(3), max(last(r)$time), by ="quarter"),
value = last_values) %>%
mutate(time = floor_date(time, "quarter")) %>%
rename(index = value) %>%
# fill(consump, .direction = "up") %>%
# mutate(time = floor_date(time, "quarter")) %>%
# group_by(time) %>%
# mutate(index = mean(index)) %>%
drop_na()
return(forec)
}
forecast_q(r, dat)$forecast %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_q(r, dat) %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
#'series <- trendecon::ts_gtrends(c("ikea", "saturn"), time = "2018-01-01 2021-01-01")
#'seas_adj(series, freq = "month", method = "firstdiff")
#' @examples
#'series <- trendecon::ts_gtrends(c("ikea", "saturn"), time = "2018-01-01 2021-01-01")
#'seas_adj(series, freq = "month",  method = "firstdiff")
#'@import dplyr tsbox zoo
#'@import rJava
#' @importFrom RJDemetra x13
#' @importFrom gtrendsR gtrends
#'@export
seas_adj <-function(series, freq = "month", method = "arima"){
if(method == "arima"){
#Saisonbereinigung mit X-13 ARIMA
if (!("id" %in% names(series))) series <- mutate(series, id = "id")
series <- ts_ts(series)
h <- function(ts){
m <- x13(ts)
return(m$final$series[,"sa"])
}
if (identical(dim(series), NULL)){
series <- ts_tbl(h(series))
}
if (dim(series)[2] > 1){
series <- as.list(series)
series <- lapply(series, h)
n <- names(series)
t1 <- series[[1]]
for (i in 2:length(series)) t1 <- ts_c(t1, series[[i]])
dimnames(t1)[[2]] <- n
series <- ts_tbl(t1)
}
}
if(method == "firstdiff"){     #Saisonbereinigung mit ersten Differenzen mit lag = 4
#da gerade Quartalsdaten. Fuer monatsdaten lag = 12
if (!("id" %in% names(series))) series <- mutate(series, id = "id")
if (freq == "month") k = 12
if (freq == "quarter") k = 4
series <- series %>%
group_by(id) %>%
mutate(value = c(rep(0,k), diff(value, k))) %>% #Wenn Monatsdaten hier 12 statt 4
ungroup()
}
series
}
#' @importFrom dplyr bind_rows
#' @importFrom gtrendsR gtrends
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr pivot_wider
#' @importFrom stats prcomp
#' @importFrom tidyselect any_of
#' @importFrom tsbox ts_ts
#' @importFrom lubridate as_date
#' @importFrom stringr str_c
#' @export
pca <- function(keyword = NA,
category = 0,
geo = "DE",
time = str_c("2006-01-01 ", Sys.Date())) {
start <- str_sub(time, 1, 10)
end <- str_sub(time, 12, 21)
stopifnot("Nur keywords oder categories darf angegeben werden" = is.na(keyword) | category == 0)
# Check if function is used on the first day of the month
day <- format(end, format = "%d")
if (day == "01") {
# If indeed it is the first day of the month,
# we need to shorten the dates vector by one month because
# gtrends data don't include the first day of the month if that's today.
end <- seq(end, length = 2, by = "-1 months")[2]
}
dates <- seq.Date(as.Date(start), as.Date(end), by = "month")
dat <- tibble::tibble()
for (kw in keyword) {
for (cat in category) {
temp <-
tibble::as_tibble(gtrends(
keyword = kw,
category = cat,
geo = geo,
time = "all"
)$interest_over_time)
if (nrow(temp) == 0) {
stop(str_c("Keine Daten fuer Kategorie ", cat))
}
if ("keyword" %in% names(temp)) {
temp <- select(temp, -category)
}
temp <- temp %>%
mutate(date = as_date(date)) %>%
select(date, key = any_of(c("keyword", "category")), value = hits) %>%
filter(date %in% dates)
dat <- bind_rows(dat, temp)
}
}
pc <- bind_cols(date = dates, as_tibble(prcomp(ts_ts(dat))$x))
dat <- select(pivot_wider(dat, names_from = key, values_from = value), -date)
result <- bind_cols(pc, dat)
return(result)
}
unlink('vignettes/ifwtrends-intro_cache', recursive = TRUE)
library(rmarkdown)
render("ifwtrends-intro.Rmd")
render("/vignettes/ifwtrends-intro.Rmd")
getwd()
render("/vignettes/ifwtrends-intro.Rmd")
render("vignettes/ifwtrends-intro.Rmd")
#'
#' factorR2(series, factors, plot = T)
#' }
#' @import tibble ggplot2 magrittr
#' @importFrom dplyr bind_rows
#' @importFrom dplyr bind_cols
#' @importFrom tidyr pivot_longer
#' @importFrom stringr str_c
#' @importFrom stats lm
#' @export
factorR2 <- function(series, factors, plot = F) {
stopifnot("series must contain leading time column" = class(series[[1]]) == "Date")
stopifnot("factors must contain leading time column" = class(factors[[1]]) == "Date")
R2 <- vector("list", length = (dim(series)[2] - 1))
# Helper to get the R2
f <- function(series) {
s <- summary(lm(factors[-1][[i]] ~ series))
s$r.squared
}
# Apply the helper function throughout both dfs
for (i in seq_along(factors[-1])) {
R2[[i]] <- apply(series[-1], 2, f)
}
# Combine the results
res <- bind_cols(
tibble(factors = str_c("PC", 1:length(factors[-1]))),
bind_rows(R2)
)
if (!plot) {
# Plot is not displayed
return(res)
} else {
# Conversion to long tibble for creating a ggplot
pcomp <- pivot_longer(factors, -date, names_to = "series", values_to = "value")
series <- pivot_longer(series, -date, names_to = "series", values_to = "value")
r2 <- pivot_longer(res, -factors, names_to = "series", values_to = "R2")
# ggplot barplot
plt <- r2 %>%
# filter(factors == "PC1") %>%
ggplot(aes(x = series, y = R2)) +
geom_bar(stat = "identity") +
facet_wrap(~factors, ncol = 1) +
theme(
axis.title.x = element_blank(),
axis.text.x = element_text(angle = 60, size = 6, vjust = 1, hjust = 1)
) +
labs(title = "R squared of the regression on different principal components") +
scale_y_continuous(breaks = c(0, 0.5, 1))
return(list(res = res, plot = plt))
}
}
render("vignettes/ifwtrends-intro.Rmd")
#' @importFrom tidyr pivot_wider
#' @importFrom stats prcomp
#' @importFrom tidyselect any_of
#' @importFrom lubridate as_date
#' @importFrom stringr str_c
#' @importFrom gtrendsR gtrends
#' @examples \dontrun{
#' g_index(keyword = c("ikea", "saturn"), time = "2018-01-01 2021-01-01")
#' }
#' @export
g_index <- function(keyword = NA,
category = 0,
geo = "DE",
time = str_c("2006-01-01 ", Sys.Date()),
lags = 0) {
start <- str_sub(time, 1, 10)
end <- str_sub(time, 12, 21)
dates <- seq.Date(from = as.Date(start), to = as.Date(end), by = "month")
# data containing a trend calculated on 200 GTrends time series'.
fit <- readRDS("data/comtrend.rds") %>%
select(time = date, trend) %>%
filter(time >= as.Date(start))
g_dat2 <- ts_gtrends(
keyword = keyword,
category = category,
geo = "DE",
time = time
) %>%
mutate(value = log(value)) %>%
mutate(value = replace(value, value == -Inf, NA_real_)) %>%
mutate(value = na.approx(value, rule = 2))
if (!("id" %in% names(g_dat2))) {
# Add category
g_dat2 <- mutate(
g_dat2,
id = as.character(
as.vector(sapply(category, rep, length(dates)))
)
)
}
g_dat_adj <- g_dat2 %>%
left_join(fit, by = "time") %>%
mutate(time = as.Date(time), adj = value - trend) %>%
select(id, time, adj) %>%
seas_adj(freq = "quarter", method = "arima") %>%
rename(s_adj = value) %>%
unique()
if (!("id" %in% names(g_dat_adj))) {
g_dat_adj <- mutate(
g_dat_adj,
id = as.character(rep(category, each = length(dates)))
)
}
index <- g_dat_adj %>%
group_by(id)
# Add lagged columns
if (lags >= 1) index <- mutate(index, lag_1 = lag(s_adj))
if (lags >= 2) index <- mutate(index, lag_2 = lag(s_adj, 2))
if (lags >= 3) index <- mutate(index, lag_3 = lag(s_adj, 3))
if (lags == 4) index <- mutate(index, lag_4 = lag(s_adj, 4))
index <- index %>%
ungroup() %>%
rename(lag_0 = s_adj) %>%
filter(across(everything(), ~ !is.na(.))) %>%
pivot_longer(cols = -c(id, time), names_to = "lag", values_to = "value") %>%
pivot_wider(names_from = c(id, lag), values_from = value)
return(index)
}
render("vignettes/ifwtrends-intro.Rmd")
library(knitr)
library(dplyr)
library(tibble)
library(ggplot2)
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = g_index)
readRDS("data/comtrend.rds")
#' @importFrom tidyr pivot_wider
#' @importFrom stats prcomp
#' @importFrom tidyselect any_of
#' @importFrom lubridate as_date
#' @importFrom stringr str_c
#' @importFrom gtrendsR gtrends
#' @examples \dontrun{
#' g_index(keyword = c("ikea", "saturn"), time = "2018-01-01 2021-01-01")
#' }
#' @export
g_index <- function(keyword = NA,
category = 0,
geo = "DE",
time = str_c("2006-01-01 ", Sys.Date()),
lags = 0) {
start <- str_sub(time, 1, 10)
end <- str_sub(time, 12, 21)
dates <- seq.Date(from = as.Date(start), to = as.Date(end), by = "month")
# data containing a trend calculated on 200 GTrends time series'.
fit <- readRDS("data/comtrend.rds") %>%
select(time = date, trend) %>%
filter(time >= as.Date(start))
g_dat2 <- ts_gtrends(
keyword = keyword,
category = category,
geo = "DE",
time = time
) %>%
mutate(value = log(value)) %>%
mutate(value = replace(value, value == -Inf, NA_real_)) %>%
mutate(value = na.approx(value, rule = 2))
if (!("id" %in% names(g_dat2))) {
# Add category
g_dat2 <- mutate(
g_dat2,
id = as.character(
as.vector(sapply(category, rep, length(dates)))
)
)
}
g_dat_adj <- g_dat2 %>%
left_join(fit, by = "time") %>%
mutate(time = as.Date(time), adj = value - trend) %>%
select(id, time, adj) %>%
seas_adj(freq = "quarter", method = "arima") %>%
rename(s_adj = value) %>%
unique()
if (!("id" %in% names(g_dat_adj))) {
g_dat_adj <- mutate(
g_dat_adj,
id = as.character(rep(category, each = length(dates)))
)
}
index <- g_dat_adj %>%
group_by(id)
# Add lagged columns
if (lags >= 1) index <- mutate(index, lag_1 = lag(s_adj))
if (lags >= 2) index <- mutate(index, lag_2 = lag(s_adj, 2))
if (lags >= 3) index <- mutate(index, lag_3 = lag(s_adj, 3))
if (lags == 4) index <- mutate(index, lag_4 = lag(s_adj, 4))
index <- index %>%
ungroup() %>%
rename(lag_0 = s_adj) %>%
filter(across(everything(), ~ !is.na(.))) %>%
pivot_longer(cols = -c(id, time), names_to = "lag", values_to = "value") %>%
pivot_wider(names_from = c(id, lag), values_from = value)
return(index)
}
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = g_index)
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = g_index)
#' @importFrom tidyr pivot_wider
#' @importFrom stats prcomp
#' @importFrom tidyselect any_of
#' @importFrom lubridate as_date
#' @importFrom stringr str_c
#' @importFrom gtrendsR gtrends
#' @examples \dontrun{
#' g_index(keyword = c("ikea", "saturn"), time = "2018-01-01 2021-01-01")
#' }
#' @export
g_index <- function(keyword = NA,
category = 0,
geo = "DE",
time = str_c("2006-01-01 ", Sys.Date()),
lags = 0) {
start <- str_sub(time, 1, 10)
end <- str_sub(time, 12, 21)
dates <- seq.Date(from = as.Date(start), to = as.Date(end), by = "month")
# data containing a trend calculated on 200 GTrends time series'.
getwd()
fit <- readRDS("data/comtrend.rds") %>%
select(time = date, trend) %>%
filter(time >= as.Date(start))
g_dat2 <- ts_gtrends(
keyword = keyword,
category = category,
geo = "DE",
time = time
) %>%
mutate(value = log(value)) %>%
mutate(value = replace(value, value == -Inf, NA_real_)) %>%
mutate(value = na.approx(value, rule = 2))
if (!("id" %in% names(g_dat2))) {
# Add category
g_dat2 <- mutate(
g_dat2,
id = as.character(
as.vector(sapply(category, rep, length(dates)))
)
)
}
g_dat_adj <- g_dat2 %>%
left_join(fit, by = "time") %>%
mutate(time = as.Date(time), adj = value - trend) %>%
select(id, time, adj) %>%
seas_adj(freq = "quarter", method = "arima") %>%
rename(s_adj = value) %>%
unique()
if (!("id" %in% names(g_dat_adj))) {
g_dat_adj <- mutate(
g_dat_adj,
id = as.character(rep(category, each = length(dates)))
)
}
index <- g_dat_adj %>%
group_by(id)
# Add lagged columns
if (lags >= 1) index <- mutate(index, lag_1 = lag(s_adj))
if (lags >= 2) index <- mutate(index, lag_2 = lag(s_adj, 2))
if (lags >= 3) index <- mutate(index, lag_3 = lag(s_adj, 3))
if (lags == 4) index <- mutate(index, lag_4 = lag(s_adj, 4))
index <- index %>%
ungroup() %>%
rename(lag_0 = s_adj) %>%
filter(across(everything(), ~ !is.na(.))) %>%
pivot_longer(cols = -c(id, time), names_to = "lag", values_to = "value") %>%
pivot_wider(names_from = c(id, lag), values_from = value)
return(index)
}
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = g_index)
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = g_index)
roll(keyword = c("ikea", "saturn"),
geo = "DE",
start_series = "2011-01-01",
start_period = "2018-05-01",
end = "2018-12-01",
fun = ts_gtrends)
render("vignettes/ifwtrends-intro.Rmd")
render("vignettes/ifwtrends-intro.Rmd")
render("vignettes/ifwtrends-intro.Rmd")
render("vignettes/ifwtrends-intro.Rmd")
render("vignettes/ifwtrends-intro.Rmd")
