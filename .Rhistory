mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
print("wait")
build_model(lag(r)[[14]])
print("done")#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant quarter
forec <- tibble(time = seq.Date(max(first(r)$time)+months(3), max(last(r)$time), by ="quarter"),
value = last_values) %>%
mutate(time = floor_date(time, "quarter")) %>%
rename(index = value)
act_model = build_model(last(r))
return(list(forec = forec,             #returns forcasted values and
act_model = act_model))     #model estimated with contemporary data
}
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_q <- function(r_list, dat, fd = T){
r_raw <- r_list[1:length(r_list) %% 3 == 0]
r_raw <- lapply(r_raw, function(x){
mutate(x, time = floor_date(time, "quarter")) %>% #aggregate GT Data to quarter
group_by(time) %>%                              #
transmute_at(.vars = vars(-time), .funs =  mean) %>%  #
ungroup() %>%
unique()
})
if (fd) r_raw <- lapply(r_raw, function(x) mutate(x, time = time, #first differences if fd=T set
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used"))
r_raw <- lapply(r_raw, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) %>%
mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant quarter
forec <- tibble(time = seq.Date(max(first(r)$time)+months(3), max(last(r)$time), by ="quarter"),
value = last_values) %>%
mutate(time = floor_date(time, "quarter")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))     #model estimated with contemporary data
}
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_q(r_list2, dat, fd = T)$last_model
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_m <- function(r_list, dat, fd = T){
if (fd) r_list <- lapply(r_list, function(x) mutate(x, time = time,
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used")) #first differences
r_raw <- lapply(r_list, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) %>%
mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_))) %>%
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant month
forec <- tibble(time = seq.Date(max(first(r)$time)+months(1), max(last(r)$time), by ="month"),
value = last_values) %>%
mutate(time = floor_date(time, "month")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))
}
r_list2 <- r_list[1:45]
forecast_m <- function(r_list, dat, fd = T){
if (fd) r_list <- lapply(r_list, function(x) mutate(x, time = time,
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used")) #first differences
r_raw <- lapply(r_list, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) %>%
mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant month
forec <- tibble(time = seq.Date(max(first(r)$time)+months(1), max(last(r)$time), by ="month"),
value = last_values) %>%
mutate(time = floor_date(time, "month")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))
}
r_list2 <- r_list[1:45]
s_imports <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`BD IMPORTS - SERVICES CONA`))
dat <- s_imports %>%
mutate(value = c(0, diff(log(value),1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
s_imports <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(log(value),1)) ) %>%
filter(time < as.Date("2021-08-01"))
tail(dat)
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_m <- function(r_list, dat, fd = T){
if (fd) r_list <- lapply(r_list, function(x) mutate(x, time = time,
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used")) #first differences
r_raw <- lapply(r_list, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) %>%
mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
build_model <- function(series){ #Function to estimate the model
print(1)
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant month
forec <- tibble(time = seq.Date(max(first(r)$time)+months(1), max(last(r)$time), by ="month"),
value = last_values) %>%
mutate(time = floor_date(time, "month")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))
}
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
tail(last(r_list2))
r_list2 <- r_list[1:44]
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(log(value),1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
r_list2 <- r_list[1:44]
tail(last(r_list2))
tail(dat)
r_list2 <- r_list[1:43]
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(log(value),1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
tail(dat)
tail(last(r_list2))
tail(dat)
view(dat)
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
view(dat)
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
test <- readxl::read_xlsx("data/consumer_exp_GER.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
names(readxl::read_xlsx("data/consumer_exp_GER.xlsx"))
test <- readxl::read_xlsx("data/consumer_exp_GER.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`BD CONSUMER EXPENDITURE CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
tail(dat)
r_list2 <- r_list[1:40]
tail(last(r_list2))
r_list2 <- r_list[1:41]
tail(last(r_list2))
tail(dat)
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
r_list2
r_list2[[1]]
view(r_list2[[1]])
view(dat)
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`BD CONSUMER EXPENDITURE CONA`))
r_list2 <- r_list[1:43]
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`BD CONSUMER EXPENDITURE CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
view(dat)
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`BD CONSUMER EXPENDITURE CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
names(readxl::read_xlsx("data/test_monthly_series.xlsx"))
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
view(dat)
view(last(r_list2))
r_list2 <- r_list[1:42]
test <- readxl::read_xlsx("data/test_monthly_series.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "month"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
forecast_m <- function(r_list, dat, fd = T){
if (fd) r_list <- lapply(r_list, function(x) mutate(x, time = time,
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used")) #first differences
r_raw <- lapply(r_list, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) %>%
mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
view(r[[1]])
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant month
forec <- tibble(time = seq.Date(max(first(r)$time)+months(1), max(last(r)$time), by ="month"),
value = last_values) %>%
mutate(time = floor_date(time, "month")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))
}
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
view(dat)
forecast_m <- function(r_list, dat, fd = T){
if (fd) r_list <- lapply(r_list, function(x) mutate(x, time = time,
across(.cols = -1, function(y) c(0, diff(y,1))),
.keep = "used")) #first differences
r_raw <- lapply(r_list, function(x){
left_join(x, dat[1:nrow(x), ], by = "time") %>%
select(time, dat = value, everything()) %>%
filter(time != as.Date("2011-01-01")) %>% #omit structural breaks
filter(time != as.Date("2016-01-01")) #%>%
#mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
#mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
})
# use PCA
# r_factors <- lapply(r_raw, function(x){
#   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
#   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
#     drop_na()
# })
r <- r_raw #set r <- r_factors to use PCA-Model
view(r[[1]])
build_model <- function(series){ #Function to estimate the model
y <- as.matrix(series[2])
x <- as.matrix(series[-c(1,2)])
cv <- cv.glmnet(x, y, alpha = 0)
model <- glmnet(x, y, alpha = 0, lambda = 0)#cv$lambda.min) #alpha = 1 LASSO
model                                                    #lambda= 0 OLS
}
covariats <- lapply(r, function(x) as.matrix(x[-c(1,2)])) #Trends Data to forecast with
#previous estimated model
models <- lapply(lag(r)[-1], function(x) build_model(x))           #estimate model
pred_values <- mapply(predict, models, covariats[-c(1)]) #forecast
last_values <- sapply(pred_values, last) #select last value in each vintage as forecast
#for relevant month
forec <- tibble(time = seq.Date(max(first(r)$time)+months(1), max(last(r)$time), by ="month"),
value = last_values) %>%
mutate(time = floor_date(time, "month")) %>%
rename(index = value)
last_model = last(models)
return(list(forec = forec,             #returns forcasted values and
last_model = act_model))
}
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
r_list2
dat
test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time < as.Date("2021-08-01"))
test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time && time < as.Date("2021-08-01"))
test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") < time && time < as.Date("2021-08-01"))
test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") < time & time < as.Date("2021-08-01"))
test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time & time < as.Date("2021-08-01"))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time & time < as.Date("2021-08-01"))
forecast_m(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
r_list2 <- r_list[1:42]
tail(last(r_list2))
test <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`WG UNEMPLOYMENT RATE, REGISTERED (CAL ADJ) SADJ`))
names(readxl::read_xlsx("data/service_imports.xlsx"))
test <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`BD IMPORTS - SERVICES CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time & time < as.Date("2021-08-01"))
tail(dat)
r_list2 <- r_list[1:42]
test <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`BD IMPORTS - SERVICES CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time & time < as.Date("2021-08-01")) %>%
drop_na()
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
test <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`BD IMPORTS - SERVICES CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(as.Date("2006-03-01") <= time & time < as.Date("2021-08-01"))
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
dat
test <- readxl::read_xlsx("data/service_imports.xlsx") %>%
transmute(time = floor_date(as.Date(Name), "quarter"), value = as.numeric(`BD IMPORTS - SERVICES CONA`))
dat <- test %>%
mutate(value = c(0, diff(value,1)) ) %>%
filter(time < as.Date("2021-08-01"))
forecast_q(r_list2, dat, fd = T)$forec %>%
left_join(dat, by = "time") %>%
pivot_longer(cols = -time, names_to = "id", values_to = "value") %>%
ggplot(aes(x=  time, y = value, color = id)) +
geom_line()
