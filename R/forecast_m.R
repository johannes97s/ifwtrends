###
# Takes a list of vintages r_list, generated with roll and a monthly target variable dat
# to evaluate a forecast.
# Google Data should be log-transformed
# currently it uses a RIDGE-Regression but other models such as OLS, LASSO or
# PCA are available (change the relevant lines of code)

#' Monthly forecast evaluation of vintages
#'
#' @description
#'
#' `r lifecycle::badge('experimental')`
#'
#' [forecast_m()] uses monthly vintages generated by [roll()]
#' to predict the value of another time series for the next month.
#' Due to complications, this function **does not work currently**.
#'
#' @param r_list A Google Trends time series in form of a tibble (or tsibble)
#' which is used to predict the next month in data.
#' @param data A tibble with some data you
#' want to predict for the next month
#' that is somewhat correlated with the data in r_list.
#' @param fd A logical value to indicate if you want to use the first differences
#' in r_list (true) or normal values (false).
#'
#' @section Methods:
#' Google Data should be log-transformed
#' currently it uses a RIDGE-Regression
#' but other models such as OLS, LASSO or
#' PCA are available.
#'
#' @return Returns a list with the the predicted data and the used model
#' results.
#'
#' @examples
#' 1 + 1
#' 1 + 2
#' @importFrom magrittr %>%
#' @importFrom glmnet cv.glmnet
#' @importFrom glmnet glmnet
#' @importFrom stats predict
#' @importFrom tibble as_tibble
#' @importFrom tibble tibble
#' @export
forecast_m <- function(r_list, data, fd = T) {
  colnames(data)[1] <- "time"
  print("colnames ok")
  if (fd) {
    r_list <-
      lapply(
        r_list,
        function(x) {
          mutate(x,
            time = time,
            across(
              .cols = last_col(),
              # first differences
              function(y) c(0, diff(y, 1))
            )
          )
        }
      )
  }

  r_raw <- lapply(r_list, function(x) {
    left_join(x, data[1:nrow(x), ], by = "time") %>%
      select(time, data = value, everything()) %>%
      filter(time != as.Date("2011-01-01")) %>% # omit structural breaks
      filter(time != as.Date("2016-01-01")) %>%
      mutate(across(everything(), function(y) replace(y, y == -Inf, NA_real_))) %>%
      mutate(across(everything(), function(y) replace(y, y == Inf, NA_real_)))
  })

  # use PCA
  # r_factors <- lapply(r_raw, function(x){
  #   pc <- as_tibble(prcomp(x[-c(1,2)])$x)
  #   bind_cols(x[c(1,2)], pc[,1:min(20, length(r_raw[[1]])-2)]) %>% #number of PCs
  #     drop_na()
  # })

  r <- r_raw # set r <- r_factors to use PCA-Model


  build_model <- function(series) {
    # Function to estimate the model
    y <- as.matrix(series[2])
    x <- as.matrix(series[-c(1, 2)])



    # cv <- cv.glmnet(x, y, alpha = 1)
    # model <- glmnet(x, y, alpha = 1, lambda =0)# cv$lambda.min) #alpha = 1 LASSO
    # model                                                    #lambda= 0 OLS
    lm(data ~ ., data = series[-1])
  }

  covariats <- lapply(r, function(x) x[-c(1, 2)]) # Trends Data to forecast with
  # previous estimated model
  models <- lapply(lag(r)[-1], function(x) build_model(x)) # estimate model


  pred_values <- mapply(predict, models, covariats[-c(1)]) # forecast

  last_values <- sapply(pred_values, last) # select last value in each vintage as forecast
  # for relevant month


  forec <- tibble(
    time = seq.Date(max(first(r)$time) + months(1), max(last(r)$time), by = "month"),
    value = last_values
  ) %>%
    mutate(time = floor_date(time, "month")) %>%
    rename(index = value)


  last_model <- last(models)
  s_niv <- lapply(models, function(x) summary(x)$coef[, 4])
  return(list(
    forec = forec, # returns forcasted values and
    last_model = last_model,
    s_niv = s_niv
  ))
}
